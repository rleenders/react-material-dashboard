## Coding Test

### Design Perspective:
By in large, I tried to keep my solution's design congruent with
the rest of the React Material Dashboard. As such I applied minimal custom styling. The only departure from this was implementing a modal to display sales details around a particular title. This was a cleaner approach than attempting to embed the charts in the same page as the table, and drawing a user's attention around the screen. I ended up using select lists for genre and platform as the list of items is relatively short. So there it little need for the added complexity of a typeahead. Publisher however is large enough (you have to scroll to see all items) that it warranted a typeahead for ease of use. It would have been nice to include partial match filtering as well, but that does not appear to be supported by the api.

### Engineering perspective:
* API interaction: I created a simple library "codingAPI.js" to abstract out the api interactions. This is essentially just a wrapper for the default Request/fetch library. In the case of a production app, I would implement robust error handling, and provide actual communication to the user.
* Computation: for this project I kept all computation imbedded within the relevant components, each chart handles its own calculations, and in the case of the sales breakdown per platform, also requests its own data. Since the particular computed values are rather basic, I just wrapped them in a useEffect Hook to ensure they are updated whenever its dependencies change.
* Table Management: This bit caused me the largest amount of consternation, the combination of the stripped down api (returning only rows of data, and no metadata), and MUI's somewhat opinionated pagination component led me to make a hack of sorts in the interest of time. The pagination component will only work if it detects that the count of items, exceeds the number of rows set for the table. Since I don't know the max number of rows for a given query, I instead checked to see if the number of items was less than the default limit (20), if true, I could safely assume I was on the last page for that particular query, and would set the count to match the expected number of rows (page * limit). If the returned rows matches the limit, I assume there is more data, and increment the count to be one higher than could be displayed (page * limit) + 1 so that the next page button stays available.
* I included two charts related to sales information of a particular title. The first uses the already existing info, to display a pie chart of the percentage of sales that occurred in the provided regions (North America, Europe, Asia, Other). The second more computationally intensive, it retrieves all records for a certain game, and computes the percent of global sales per platform.

### Potential Improvements
* Since this was a quick project, it includes only happy path handling. In addition to adding some guardrails in the form of general API error handling and logging. Wrapping key components in error boundaries' so the entire DOM doesn't unmount when something goes wrong. And adding tests to validate basic API library functionality, business logic, and general rendering validity.
* Normally I'd extract the business logic from the component itself, for something as computationally complex as a dashboard, I would likely shunt the business logic either to the webserver, or to a webworker so that it doesn't interfere with render efficiency.
* I would also make some improvements to the webservice if possible. Instead of just returning raw data in my response. I would include a decorated object that could provide helpful metadata (like relevant links, counts, totals, etc). This would in turn allow for cleaner pagination, and more complex queries to get more interesting results.
* Finally, I'd love to make a more rich drilldown into the actual games data. I picked two simple pie charts that could be populated without a subsequent request, and a single request. But some of the more interesting information would be looking at trend data for game franchises and platforms, but that information would be a challenge to collate with blind retrieval. My ideal would be to be able to grab arbitrary datapoints from the table, and create some custom reporting around it.
